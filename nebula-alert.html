<!--
@license
Copyright (c) 2017 Ars Nebula LLC.
This code may be used under the terms found in LICENSE.md of this repository.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-a11y-announcer/iron-a11y-announcer.html">
<link rel="import" href="../nebula-style-attributes-behavior/nebula-style-attributes-behavior.html">
<link rel="import" href="../nebula-button/nebula-button.html">

<!--
`<nebula-alert>` is a web component to display an alert dialog.
  
The overlay uses a `fixed` position that fills the browser screen, and provides a backdrop, and a centered container. The element uses conditional rendering of the following properties to support displaying alternate types of progress:

* title
* icon
* text
* buttons

The `title` and `text` properties support **a11y**. When either property is changed, the property value is announced for screen readers.

The `value` property provides a read-only value used to determine how the dialog was closed. If the dialog was canceled by pressing the `ESC` key or clicking the backdrop, the `value` will be undefined, otherwise, the value will be the index of the button that was clicked.

## Usage

Add and configure the element using attributes: 

```html
<nebula-alert
  id="loader"
  title="Alert"
  icon="warning"
  text="You have been warned"
  buttons='["OK"]'
  background-color="black"
  color="white"
  value="{{alertValue}}>
</nebula-alert>
```

Add and configure the element programatically. The `show` method will ensure the element is appended and removed from the `document.body` automatically. The method returns a promise that is resolved once the element closing animation is complete.

```js
// create the element
var alert = Polymer.Base.create('nebula-alert', {
  title: 'Alert',
  icon: 'warning',
  text: 'You have been warned',
  buttons: ['OK']
})

// show the element - automatically appended to document.body
alert.show().then(function(value) {
  console.log('The alert has been closed', value)
})
```

## Style

You can style the component using the following CSS custom properties and mixins:

Custom property | Description | Default
:--- | :--- | :---
`--nebula-alert-backdrop-color` | The background color of the host element. | hsla(0, 0%, 0%, 0.6)
`--nebula-alert-background-color` | The background color of the content container. | hsla(0, 0%, 0%, 0.6)
`--nebula-alert-border-color` | The border color of the content container. | transparent
`--nebula-alert-button-color` | The border color of the content container. | grey
`--nebula-alert-color` | The foreground color of child elements. | | white
`--nebula-alert-transition-duration` | The duration of the opening/closing animation. | 0.4s
`--nebula-alert-z-index` | The stacking order of the element. | 9999
`--nebula-alert` | Mixin applied to the host element.
`--nebula-alert-container` | Mixin applied to the content container element.
`--nebula-alert-title` | Mixin applied to the title element.
`--nebula-alert-text` | Mixin applied to the text element.
`--nebula-alert-icon` | Mixin applied to the icon element.
`--nebula-alert-button` | Mixin applied to the button elements.

The following styles can also be set as attributes on the element:

- `backdrop-color`
- `border-color`
- `background-color`
- `button-color`
- `color`

@demo demo/index.html
-->

<dom-module id="nebula-alert">
  <template>
    <style>
      :host {
        --nebula-alert-backdrop-color: hsla(0, 0%, 0%, 0.6);
        --nebula-alert-background-color: hsl(0, 0%, 15%);
        --nebula-alert-border-color: transparent;
        --nebula-alert-button-color: grey;
        --nebula-alert-color: white;
        --nebula-alert-z-index: 9999;
        --nebula-alert-transition-duration: 0.4s;
        position: fixed;
        font-family: sans-serif;
        font-size: 1rem;
        z-index: var(--nebula-alert-z-index);
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--nebula-alert-backdrop-color);
        color: var(--nebula-alert-color);
        margin: 0;
        padding: 0;
        border: 0;
        visibility: hidden;
        opacity: 0;
        transition: opacity var(--nebula-alert-transition-duration) linear, visibility 0s linear var(--nebula-alert-transition-duration);
        @apply --layout-vertical;
        @apply --layout-center-center;
        @apply --nebula-alert;
      }
      :host([opened]) {
        visibility: visible;
        opacity: 1;
        transition: opacity var(--nebula-alert-transition-duration) linear;
      }
      #container {
        width: fit-content;
        min-width: 288px;
        max-width: 400px;
        cursor: default;
        align-items: stretch;
        margin: 16px;
        padding: 16px;
        outline: none;
        background-color: var(--nebula-alert-background-color);
        border: 1px solid transparent;
        @apply --layout-vertical;
        @apply --layout-center-center;
        @apply --nebula-alert-container;
      }
      #container > #title,
      #container > #icon,
      #container > #text {
        margin: 4px 0;
        text-align: center;
      }
      #title {
        font-size: 1.2rem;
        @apply --nebula-alert-title;
      }
      #icon {
        height: 32px;
        width: 32px;
        @apply --nebula-alert-icon;
      }
      #text {
        @apply --nebula-alert-text;
      }
      #buttons {
        width: 100%;
        margin: 16px 0 0 0;
        text-align: center;
        @apply --layout-vertical;
        @apply --layout-center-justified;
      }
      nebula-button {
        margin: 4px 0;
        --nebula-button-color: var(--nebula-alert-button-color);
        @apply --nebula-alert-button;
      }
    </style>
    <div id="container" on-tap="_onContainerTap" tabindex="-1">
      <template is="dom-if" if="[[icon]]">
        <div>
          <iron-icon id="icon" icon="[[icon]]"></iron-icon>
        </div>
      </template>
      <template is="dom-if" if="[[title]]">
        <div id="title">[[title]]</div>
      </template>
      <template is="dom-if" if="[[text]]">
        <div id="text">[[text]]</div>
      </template>
      <template is="dom-if" if="[[buttons]]">
        <div id="buttons">
          <template is="dom-repeat" items="[[buttons]]">
            <nebula-button
              data-index$="[[index]]"
              on-tap="_onButtonTap">
              {{item}}    
            </nebula-button>
          </template>
        </div>
      </template>
    </div>
  </template >
  <script>
    Polymer({
      /**
       * Event triggered when element opening animation is complete.
       * @event opened
       */
      /**
       * Event triggered when element closing animation is complete.
       * @event closed
       */ 
      is: 'nebula-alert',
      behaviors: [
        Nebula.StyleAttributesBehavior
      ],      
      hostAttributes: {
        'role': 'alertdialog'
      },
      properties: {
        /**
        * True if the element is opened, otherwise false.
        */
        opened: {
          type: Boolean,
          reflectToAttribute: true,
          notify: true,
          value: false
        },
        /**
        * The title to display.
        */
        title: {
          type: String
        },
        /**
        * The icon key to display as a spinner.
        */
        icon: {
          type: String
        },
        /**
        * The text message to display.
        */
        text: {
          type: String
        },
        /**
        * An array of buttons to generate.
        */
        buttons: {
          type: Array
        },
        /**
        * The index value of the button tapped to close the element.
        */
        value: {
          type: String,
          readOnly: true,
          notify: true
        },
        /**
        * Map of style attributes that can be used to update CSS variables.
        */
        styleAttributes: {
          type: Object,
          readOnly: true,
          value: function() {
            return {
              'color': '--nebula-alert-color',
              'background-color': '--nebula-alert-background-color',
              'border-color': '--nebula-alert-border-color',
              'backdrop-color': '--nebula-alert-backdrop-color',
              'button-color': '--nebula-alert-button-color'
            }
          }
        }
      },
      observers: [
        '_onOpenedChanged(opened)',
        '_onTitleChanged(title)',
        '_onTextChanged(text)'
      ],
      listeners: {
        'transitionend': '_onTransitionEnd',
        'tap': '_onTap'
      },
      /**
      * Lifecycle event handler triggered when the element has been initialized.
      */
      ready: function() {
        Polymer.IronA11yAnnouncer.requestAvailability();
      },
      /**
      * Lifecycle handler triggered when a key is pressed down.
      * The handler is added and removed automatically when a element is opened and closed.
      */ 
      _onKey: function(e) {
        var key = e.keyCode || e.which
        if (key === 27) {
          this.cancel()
          return false
        }
      },
      /**
      * Event handler triggered when the user taps the element.
      * The element is automatically closed.
      */
      _onTap: function(e) {
        this.cancel()
        return false
      },
      /**
      * Event handler when content container is tapped.
      * It discards the event.
      */
      _onContainerTap: function(e) {
        return false
      },
      /**
      * Event handler when a content button is tapped.
      * It sets the value property, and closes the element.
      */
      _onButtonTap: function(e) {
        this._setValue(e.target.dataset.index)
        this.set('opened', false)
        return false
      },
      /**
      * Event handler triggered when opening and closing animation is complete.
      */
      _onTransitionEnd: function(e) {
        if (e.propertyName === 'opacity') {
          if (this.opened) {
            if (this.title) {
              this.fire('iron-announce', {text: this.title}, {bubbles: true })
            }
            if (this.text) {
              this.fire('iron-announce', {text: this.text}, {bubbles: true })
            }
            this.fire('opened', null, {bubbles: false})
            this.$.container.focus()
          }
          else {
            this.fire('closed', null, {bubbles: false})
          }
        }
      },
      /**
      * Property observer triggered when the value of `opened` is changed.
      */
      _onOpenedChanged: function(opened) {
        if (opened) {
          document.addEventListener('keydown', this._onKey.bind(this))
        } else {
          document.removeEventListener('keydown', this._onKey)
        }
      },
      /**
      * Progress observer triggered when the title is changed.
      * The change is announced for screen readers to support **a11y**.
      */
      _onTitleChanged: function(title) {
        if (title) {
          this.setAttribute('aria-labelledby', 'title')
          if (this.opened) {
            this.fire('iron-announce', {text: this.title}, {bubbles: true})  
          }
        } else {
          this.removeAttribute('aria-labelledby')
        }
      },
      /**
      * Progress observer triggered when the text is changed.
      * The change is announced for screen readers to support **a11y**.
      */
      _onTextChanged: function(text) {
        if (text) {
          this.setAttribute('aria-describedby', 'text')
          if (this.opened) {
            this.fire('iron-announce', {text: this.text}, {bubbles: true})
          }
        } else {
          this.removeAttribute('aria-describedby')
        }
      },
      /**
      * Hides the element.
      */
      cancel: function() {
        if (this.opened) {
          this._setValue(undefined)
          this.set('opened', false)
        }
      },
      /**
      * Displays the element.
      * A promise is returned that will resolve when the element has been closed.
      */
      show: function() {
        return new Promise(function(resolve) {
          // add element to document body if not parent
          if (!this.parentNode) {
            this._appended = true
            document.body.appendChild(this)
          }

          // listen for our own closed event and resolve promise
          var handler = function() {
            this.removeEventListener('closed', handler)

            if (this._appended) {
              this._appended = false
              document.body.removeChild(this)
            }

            resolve(this.value) 
          }
          this.addEventListener('closed', handler.bind(this))

          // open the element in a timeout closure to accomodate for animation
          // when appending new element
          setTimeout(function() {
            this.set('opened', true)
          }.bind(this))
        }.bind(this))
      }
    })
  </script>
</dom-module>